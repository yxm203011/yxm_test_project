在查询是传入的参数使用#的话是会将传入参数当成一个字符串，会自动对传入参数的数据加上一个双引号，能够很大程度防止sql注入
使用$会直接显示在sql中，可能会sql注入
比如查询某表中的某个字段
select ${字段名} from ${表名} where id = #{条件}

Mybatis的动态sql元素-
if：判断语句，单条件分支判断
choose、where、set：相当于java中的case when，多条件分支判断
Trim、where、set：辅助元素，用于处理sql拼装问题
foreach：循环语句，在in语句等列举条件常用，常用于实现批量操作

Mybatis查询时最多不好超过三个表join查询，join查询会导致查询速度慢，可以将热点表放到redis中，也可以将一些字段进行适当冗余，也可以进行两次查询

关闭一级缓存：在select标签上配置flushCache = "true"
一级缓存存在SqlSession的生命周期中，在同一个SqlSession中查询时，Mybatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中，如果同一个SqlSession中执行的方法和参数完全一致，那么会通过算法会生成相同的键值，当Map缓存对象中已经存在该键值时，则会返回缓存中的对象，任何的UPDATE,INSERT,DELETE都会清空一级缓存
二级缓存存在于SqlSessionFactory的生命周期中，可以理解为跨sqlSession；缓存是以namespace为单位的，不同namespace下的操作互不影响
setting参数cacheEnabled，这个参数时二级缓存的全局开关，默认是true，如果把这个参数设置为false，即使有后面的二级缓存的配置，也不会生效
要开启二级缓存，需要在Sql映射文件中添加配置
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true">
eviction：缓存的清空策略（LRU最近最少使用的会优先清空）
flushInterval：多长时间清一次缓存
size：缓存块大小

如果需要两个nameSpace的二级缓存共享
需要在mapper.xml文件中加上
<cache-ref namespace="">

设计模式的原则
单一职责原则：一个类或者一个接口只负责唯一项责任，尽量设计出功能单一的接口
依赖倒转原则：高层模块不应该依赖底层模块具体实现，接口高层与底层。既面向接口编程，当现实发现变化时，只需提供新的实现类，不需要修改高层模块代码；
开放-封闭原则：程序对外扩展开放，对修改关闭；换句话说，当需求发生变化时，我们可以通过添加新模块来满足新的需求，而不是通过修改原来的实现代码来满足新的需求；
迪米特法则：一个对象应该对其它对象保持最少的了解，尽量降低类与类之间的耦合度；
里氏代换原则：所有引用基类（父类）的地方必须能透明的使用其子类的对象
接口隔离原则：客户端不应该依赖他不需要的接口，一个类对另一个类的以来应该建立在最小的接口上

代理模式（Proxy）是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外的功能，如添加权限，访问控制和审计等功能。
适配器：适配器模式把一个类的接口转换成客户端期待的另外一种接口, 从而是原本应用接口不匹配而无法在一起工作的两个类能够在一起工作.